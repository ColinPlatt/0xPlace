<!DOCTYPE html><html><head><title>0xPlace</title><style>body { background-color: #0f1316;color: #fff;font-family: 'Courier New', Courier, monospace;padding: 0.25rem 1rem; }input { background: transparent;width: 5rem;margin: 1rem 1rem 0; }button { height: 2.25rem;cursor: pointer;background: #027cfd;font-family: inherit;padding: 0.25rem 1rem;color: white;margin: 1rem 1rem 0;font-size: 1rem;border-radius: 7px; }input[type="color"] { height: 2rem;padding: 0;background: transparent !important;border-radius: 10px;position: relative;border: none;cursor: pointer; }#pixel-art-area { display: flex;flex-direction: row;flex-wrap: wrap;overflow: hidden;border-radius: 4px;padding: 0.05px; }#pixel-art-area input { background: #101316; }#canvas-area { position: relative;border: 5px solid #b9b9b9; }.cursor-highlight { position: absolute;background-color: rgba(255, 255, 255, 0.3);border: 1px solid white;pointer-events: none; }#button-container { display: flex;justify-content: space-between;align-items: center;max-width: 400px;margin-bottom: 1rem; }#pixel-art-options { display: flex;align-items: center; }#color-selector-container { display: flex;width: 20rem;position: relative;align-items: center; }</style></head><body><div id="info" ><h2>0xPlace</h2><p>0xPlace is an entirely onchain canvas that let's users claim and update pixels. When a pixel is first claimed (0.0001 ETH each), the user receives 100 $PLACE tokens. Each change requires 1 $PLACE token which is paid to the current owner of the pixel.</p></div><div id="container" ><div id="button-container" ><div id="pixel-art-options" ><button id="update-btn" onclick="setPixelState()" >Update</button><button id="eraser-btn" >Erase</button><div id="color-selector-container" ><p style="margin:1rem 0.25rem 0;" >Select Colors:</p><input type="color" id="color-picker" value="#ffffff" /></div><button id="mint-btn" >Mint</button></div></div><div id="pixel-art-area" oncontextmenu="return false;" ></div></div><script>let state={config:{width:1024,height:1024,defaultColor:"#ffffff"},events:{mousedown:!1},colors:[],pixelArtArea:document.getElementById("pixel-art-area"),canvasArea:null,context:null,gridSize:2,currentStep:null,isStepComplete:!1,isLeftMouseDown:!1,isRightMouseDown:!1,dragStartX:0,dragStartY:0,dragOffsetX:0,dragOffsetY:0,zoomLevel:1,cursorSize:1,cursorHighlight:document.createElement("div"),indexedColors:"",mintButton:document.getElementById("mint-btn"),colorPicker:document.querySelector("#color-picker")};const { config, pixelArtArea, cursorHighlight, mintButton, colorPicker } = state;const setColors = () => {const currentPixels = "0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c";for (let i = 0; i < currentPixels.length; i++) {state.indexedColors.push('#' + currentPixels.slice(i, i + 6));}};const drawGrid = () => {state.context.strokeStyle = 'gray';state.context.lineWidth = 0.1;for (let x = 0; x <= state.canvasArea.width; x+=state.gridSize) {state.context.beginPath();state.context.moveTo(x, 0);state.context.lineTo(x, state.canvasArea.height);state.context.stroke();}for (let y = 0; y <= state.canvasArea.height; y+=state.gridSize) {state.context.beginPath();state.context.moveTo(0, y);state.context.lineTo(state.canvasArea.width, y);state.context.stroke();}};const handleChange = (x, y, pixelSize, color) => {if (state.currentStep !== null && ! state.isStepComplete) {for (let i = 0; i < pixelSize; i++) {for (let j = 0; j < state.currentStep.changes.length; j++) {if (state.currentStep.changes[j].x === x + i && state.currentStep.changes[j].y === y + i) {state.currentStep.changes[j].color = color;pixelExists = true;break;}}if (! pixelExists) {state.currentStep.changes.push({x: x + i, y: y + i, color: color});}}}};const handleEraser = () => {if (state.currentStep !== null) {for (let i = 0; i < state.currentStep.changes.length; i++) {const {x, y, color} = state.currentStep.changes[i];state.currentStep.erasures.push({x, y, color});}state.currentStep.changes = [];}};const handlePixelColor = (event) => {const pixelCanvas = state.canvasArea;const ctx = state.context;const rect = pixelCanvas.getBoundingClientRect();const pixelSize = state.gridSize;const offsetX = rect.left + window.scrollX * state.zoomLevel;const offsetY = rect.top + window.scrollY * state.zoomLevel;const x = Math.floor(event.offsetX / pixelSize);const y = Math.floor(event.offsetY / pixelSize);if (x > 512 || y > 512) return;const pixelIndex = y * 2 + x;ctx.fillStyle = state.activeColor;ctx.fillRect(x * pixelSize, y * pixelSize, state.cursorSize, state.cursorSize);handleChange(x, y, pixelSize, state.activeColor);};const hexToRgb = (hex) => {hex.slice(1).replace(/^(.)(.)(.)$/gi, '$1$1$2$2$3$3').match(/.{2}/g).map((c) => parseInt(c, 16));};const distance = (a, b) => {Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2) + Math.pow(a[2] - b[2], 2));};const nearestColor = (colorHex) => {state.colors.reduce((a, v, i, arr) => (a = distance(hexToRgb(colorHex), hexToRgb(v)) < a[0] ? [distance(hexToRgb(colorHex), hexToRgb(v)), v ] : a), [Number.POSITIVE_INFINITY, state.colors[0]])[1];};async function setPixelState(){const pixelCanvas = state.canvasArea;const ctx = state.context;for (let idx = 0; idx <state.indexedColors.length; idx+=2) {const colorIndex = parseInt(state.indexedColors[idx], 16);const x = idx % 512;const y = Math.floor(idx / 512);ctx.fillStyle = state.colors[colorIndex];ctx.fillRect(x * state.gridSize, y * state.gridSize, 1 * state.gridSize, 1 * state.gridSize);}}mintButton.addEventListener('click', getDelta);function getDelta(){console.log("state.changes:", state.changes);}colorPicker.addEventListener('change', function(event){const selectedColor = event.target.value;if (selectedColor) {state.activeColor = nearestColor(selectedColor);}});colorPicker.addEventListener('input', function(event){const selectedColor = event.target.value;if (selectedColor) {state.activeColor = nearestColor(selectedColor);}});pixelArtArea.addEventListener('mousedown', function(event){if (event.button == 0) {state.isLeftMouseDown = true;if (state.currentStep === null || state.isStepComplete) {state.currentStep = {changes: [], erasures: []};state.isStepComplete = false;}handlePixelColor(event);} else if (event.button == 2) {state.isRightMouseDown = true;state.dragStartX = event.clientX;state.dragStartY = event.clientY;state.dragOffsetX = state.dragStartX - pixelArtArea.offsetLeft;state.dragOffsetY = state.dragStartY - pixelArtArea.offsetTop;} else if (event.button == 1) {state.dragStartX = 0;state.dragStartY = 0;state.dragOffsetX = 0;state.dragOffsetY = 0;state.zoomLevel = 1;state.cursorSize = 1;pixelArtArea.style.transformOrigin = '100}% 100}%';pixelArtArea.style.transform = `scale(${ state.zoomLevel })`;}});</script></body></html>